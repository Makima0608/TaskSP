---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Sakuragong.
--- DateTime: 2024/5/7 15:12
---
local SPGameSummonManager = require("Feature.StarP.Script.System.SPGameSummonManager")
local SPAbility = require("Feature.StarP.Script.System.Ability.SPAbilityClasses")
local SPAbilityUtils = require("Feature.StarP.Script.System.Ability.SPAbilityUtils")
local ESpawnWay = _SP.SPAbilityUtils.EAbilitySpawnWay

local AttrEnum = _SPFeature.ServerEnum.StarPAttrType
local AttrOpEnum = _SPFeature.ServerEnum.StarPAttrOPType

local Ability_Task_Summons = UE4.Class(nil, "Ability_Task_Summons")
local EAbilitySummonMultiSpawnWay = {
    SpawnMultiByMaxNum = 0,
    SpawnMultiByTargetNum = 1
}
function Ability_Task_Summons:OnTaskStartBP(Context)
    _SP.Log("SPAbilityTask", "Ability_Task_Summons:OnTaskStartBP", Context:GetAbilityUniqueID())
    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad then
        return
    end
    if not self.IsContinuouslyGenerate then
        self.FoundTargets = {}
        local SummonID = self:GetSummonId(Context)
        local SpawnWay = self.SpawnWay
        local SocketName = self.SocketName
        local Position = Context:GetOwner():K2_GetActorLocation()

        local SummonNum = 1
        if self.MultiSpawnWay == EAbilitySummonMultiSpawnWay.SpawnMultiByMaxNum then
            SummonNum = self.MaxSummonNum
        elseif self.MultiSpawnWay == EAbilitySummonMultiSpawnWay.SpawnMultiByTargetNum then
            SummonNum = self:FindPlayerNumBySearchRadius(Context)
        end
        if SummonNum < 1 then
            return
        end
        if SummonNum > self.MaxSummonNum then
            SummonNum = self.MaxSummonNum
        end
        self:SpawnSummons(SummonNum, Context, Position, SummonID, SpawnWay, SocketName)
    else
        self.FoundTargets = {}
        ScratchPad.HasBeenGeneratedTargetList = {}
        ScratchPad.GenerateTimer = 0
        ScratchPad.PointInRangeList = {}
    end
end

function Ability_Task_Summons:OnTaskTickBP(Context, DeltaTime)
    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad then
        return
    end
    if self.SpawnWay == ESpawnWay.GenerateInRange and self.IsContinuouslyGenerate == true and self.GenerationInterval > 0 then
        ScratchPad.GenerateTimer = ScratchPad.GenerateTimer + DeltaTime
        if ScratchPad.GenerateTimer >= self.GenerationInterval then
            ScratchPad.GenerateTimer = 0
            local SourcePos = Context:GetOwner():K2_GetActorLocation()
            -- 是否使用点规避规则
            if not self.UsePointAvoidRule then
                local Summon = self:DoBasedOnRange(Context, self:GetSummonId(Context), Context:GetOwner(), SourcePos, Context:GetOwner():K2_GetActorRotation().Yaw)
                self:InheritAllPositiveBuffsFromSummoner(Context, Summon)
            else
                local EndX, EndY
                -- 根据是否启用矩形生成区域来生成一个随机点
                if not self.UseRectangleSpawnRange then
                    local HalfEdge = self.WayThreeHalfEdge
                    EndX, EndY = self:GenerateRandomPosInCircle(SourcePos, HalfEdge)
                else
                    local HalfExtentX = self.RectangleSpawnRange.X
                    local HalfExtentY = self.RectangleSpawnRange.Y
                    EndX, EndY = self:GenerateRandomPosInRectangle(SourcePos, HalfExtentX, HalfExtentY)
                end
                local SpawnPos = UE4.FVector(EndX, EndY, SourcePos.Z)
                self:DoTickSpawnInRange(Context, DeltaTime, SpawnPos)
            end
        end
    elseif self.SpawnWay == ESpawnWay.GenerateByFoundTargets then
        if ScratchPad.SummonElapsedTime == nil or ScratchPad.SummonElapsedTime > self.DetectionInterval then
            ScratchPad.SummonElapsedTime = 0
            local SummonNum = self:FindPlayerNumBySearchRadius(Context)
            local Owner = Context:GetOwner()
            local SourcePos = Owner:K2_GetActorLocation()
            self:DoBasedOnFoundTargetsLocation(SummonNum, Context, self:GetSummonId(Context), Owner,SourcePos, Owner:K2_GetActorRotation().Yaw)
        end
        ScratchPad.SummonElapsedTime = ScratchPad.SummonElapsedTime + DeltaTime
    end
end

function Ability_Task_Summons:DoTickSpawnInRange(Context, DeltaTime, NewPoint)
    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad then
        return
    end
    -- 判断新增的点是否满足时间范围要求
    if next(ScratchPad.PointInRangeList) == nil then
        -- 当前表中无点记录
        table.insert(ScratchPad.PointInRangeList, {point = NewPoint, ExistTime = 0})
        -- 即第一次随机点，可以直接生成
        local Summon = SPGameSummonManager:SpawnOneSummon(self:GetSummonId(Context), Context:GetOwner(), Context, NewPoint.X, NewPoint.Y, NewPoint.Z, Context:GetOwner():K2_GetActorRotation().Yaw)
        self:InheritAllPositiveBuffsFromSummoner(Context, Summon)
    else
        -- 更新PointList
        self:UpdatePointList(Context, DeltaTime)
        -- 判断是否在已有点的规避范围
        local canAdd = true
        for _, entry in ipairs(ScratchPad.PointInRangeList) do
            if self:IsPointInRange(entry.point, NewPoint) then
                canAdd = false
                break
            end
        end
        if canAdd then
            table.insert(ScratchPad.PointInRangeList, {point = NewPoint, ExistTime = 0})
            -- 使用新的点生成
            local Summon = SPGameSummonManager:SpawnOneSummon(self:GetSummonId(Context), Context:GetOwner(), Context, NewPoint.X, NewPoint.Y, NewPoint.Z, Context:GetOwner():K2_GetActorRotation().Yaw)
            self:InheritAllPositiveBuffsFromSummoner(Context, Summon)
        end
    end
end

function Ability_Task_Summons:UpdatePointList(Context, DeltaTime)
    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad then
        return
    end
    local PointToRemove = {}
    for i, entry in ipairs(ScratchPad.PointInRangeList) do
        if entry.ExistTime < self.AvoidTimeForSinglePoint then
            entry.ExistTime = entry.ExistTime + DeltaTime
        else
            -- 记录过期的点
            table.insert(PointToRemove, i)
        end
    end
    -- 清除过期点
    for i = #PointToRemove, 1, -1 do
        table.remove(ScratchPad.PointInRangeList, PointToRemove[i])
    end
end

function Ability_Task_Summons:IsPointInRange(SourcePoint, TargetPoint)
    if self.UseRectangleAvoidRange then
        local AvoidHalfExtentX = self.AvoidHalfExtent.X
        local AvoidHalfExtentY = self.AvoidHalfExtent.Y
        return TargetPoint.X >= (SourcePoint.X - AvoidHalfExtentX) and TargetPoint.X <= (SourcePoint.X + AvoidHalfExtentX) and
                TargetPoint.Y >= (SourcePoint.Y - AvoidHalfExtentY) and TargetPoint.Y <= (SourcePoint.Y + AvoidHalfExtentY)
    else
        local Distance = math.sqrt((SourcePoint.X - TargetPoint.X) ^ 2 + (SourcePoint.Y - TargetPoint.Y) ^ 2)
        return Distance <= self.AvoidRadius
    end
end

function Ability_Task_Summons:OnTaskEndBP(Context)
    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad then
        return
    end
    --消除召唤物？
    self.FoundTargets = nil
    ScratchPad.GenerateTimer = 0
    ScratchPad.PointInRangeList = {}
end

function Ability_Task_Summons:GetSummonId(Context)
    ---根据玩家当前大招元素选择对应元素的大招召唤物
    if self.UseUltimateSummon then
        local owner = Context:GetOwner()
        local attrComponent = _SP.SPSubSystemUtil.GetAttributeDataByAvatar(owner)
        if attrComponent then
            local elementType = attrComponent:GetSPAttributeValue(AttrEnum.SPAT_Ultimate_DamageElementType, AttrOpEnum.SPAT_OP_Base)
            local UltimateSummonTable = self.UltimateSummonMap:ToTable()
            for elementId, SummonID in pairs(UltimateSummonTable) do
                if elementId == elementType then
                    return SummonID
                end
            end
        end
    end

    if self.SummonMessage.SummonByOdds and self.SummonMessage.SummonByOdds:Length()>0 then
        if self.SummonMessage.SummonByOdds:Length() == 1 then
            return self.SummonMessage.SummonByOdds:Keys():Get(1)
        else
            local TotalOdds = 0
            local SummonsTable = self.SummonMessage.SummonByOdds:ToTable()
            local FixedOddsTable = {}
            for Id, Odds in pairs(SummonsTable) do
                if Odds <= 0 then
                    Odds = 1
                end
                TotalOdds = TotalOdds + Odds
                table.insert(FixedOddsTable, {
                    Id = Id,
                    Odds = TotalOdds
                })
            end

            local RandomValue = UE4.UKismetMathLibrary.RandomFloatInRange(0, TotalOdds)
            for _, Value in pairs(FixedOddsTable) do
                if Value.Odds >= RandomValue then
                    return Value.Id
                end
            end

        end

    end
    return self.SummonMessage.SummonID
end

--从召唤者那里继承所有正面buff
function Ability_Task_Summons:InheritAllPositiveBuffsFromSummoner(Context, summon)
    if not self.IsInheritAllPositiveBuffsFromSummoner then
        return
    end

    if not _SP.IsValid(summon) then
        return
    end

    local OwnerAbilityComp = Context:GetOwner():GetAbilityComponent()
	if OwnerAbilityComp == nil then
		return
	end
    local SummonAbilityComp = summon:GetAbilityComponent()
	if SummonAbilityComp == nil then
		return
	end
    local buffInstArray = OwnerAbilityComp:AllBuffs()
    for i = 1, buffInstArray:Length() do
        local BuffId = buffInstArray:GetRef(i)
        local buffInstance = OwnerAbilityComp:FindBuff(BuffId)
        local buffData = buffInstance:GetBuffDataTable_Lua()
        local remainTime = 0
        --如果不是无限时间才会去判断剩余时间
        if self.IsInheritAllPositiveBuffsRemainTime and buffData.Duration ~= -1 then
            remainTime = buffInstance:GetEndTime() - UE4.UMoeTimeLibrary.GetServerWorldTimeMS(_SP.GetCurrentWorld())
        end
        --检测出所有正面buff
        if buffData.EffectType == 1 then
            SummonAbilityComp:AddBuff(BuffId, summon, Context:GetInstigator(), buffInstance:GetLayer(), remainTime, "Ability_Task_Summons:InheritAllPositiveBuffsFromSummoner")
        end
    end
end

--召唤多个召唤物
function Ability_Task_Summons:SpawnSummons(SummonNum, Context, Pos, SummonID, SpawnWay, SocketName)
    if SummonNum < 1 then
        _SP.LogWarning("SPAbilityTask", "Ability_Task_Summons:SpawnSummons SummonNum < 1" )
        return
    end
    local RotZ = Context:GetOwner():K2_GetActorRotation().Yaw

    if SpawnWay == ESpawnWay.GenerateByFoundTargets then
        self:DoBasedOnFoundTargetsLocation(SummonNum, Context, SummonID, Context:GetOwner(),Pos, RotZ)
    else
        --一般情况下直接调用原来的召唤单个召唤物
        for index = 1, SummonNum do
            local Summon = self:SpawnSummon(Context, Pos, SummonID, SpawnWay, SocketName)
            self:InheritAllPositiveBuffsFromSummoner(Context, Summon)
        end
    end
end

--原召唤单个召唤物的方法
function Ability_Task_Summons:SpawnSummon(Context, Pos, SummonID, SpawnWay, SocketName)
    if self.UseQueryLocation then
        local SpawnTransform = UE4.USPAbilityFunctionLibrary.GetAbilityTargetTypeLocationTransform(Context, self.QueryLocation)
        SpawnTransform = self:GetFixedTransformAfterSpawning(Context, SpawnTransform);

        SpawnTransform.Scale3D = self.Scale3D
        local NeedSpawnTraceToGround = self.QueryLocation.m_SpawnTraceToGround or false
        local SpawnCollisionHandlingMethod = self.SpawnCollisionHandlingMethod
        return SPGameSummonManager:SpawnOneSummonByTransform(SummonID, Context, SpawnTransform, NeedSpawnTraceToGround, SpawnCollisionHandlingMethod)
    else


        -- Set summon's forward orientation as owner's
        local RotZ = Context:GetOwner():K2_GetActorRotation().Yaw

        local Summons = nil
        if Pos then
            local SummonOwner = Context:GetOwner()
            if SpawnWay == ESpawnWay.GenerateRelativeToOwner then
                Summons = self:DoBasedOnPlayer(Context, SummonID, SummonOwner, Pos, RotZ)
            elseif SpawnWay == ESpawnWay.GenerateOnSlotLocation then
                Summons = self:DoBasedOnPoint(Context, SummonID, SummonOwner, Pos, RotZ, SocketName)
            elseif SpawnWay == ESpawnWay.GenerateInRange then
                Summons = self:DoBasedOnRange(Context, SummonID, SummonOwner, Pos, RotZ)
            elseif SpawnWay == ESpawnWay.GenerateForward then
                Summons = self:DoBasedOnDirection(Context, SummonID, SummonOwner, Pos, RotZ)
            elseif SpawnWay == ESpawnWay.GenerateByTarget then
                Summons = self:DoBasedOnTarget(Context, SummonID, SummonOwner, Pos, RotZ)
            elseif SpawnWay == ESpawnWay.GenerateByBlackBoardKey then
                Summons = self:DoBasedOnBlackBoardKey(Context, SummonID, SummonOwner, Pos, RotZ)
            end

            return Summons
        end
    end
end

function Ability_Task_Summons:DoBasedOnPlayer(Context, SummonID, SummonMaster, Pos, RotZ)
    local FinalPos = Pos + self.WayOneOffset
    return SPGameSummonManager:SpawnOneSummon(SummonID, SummonMaster, Context, FinalPos.X, FinalPos.Y, FinalPos.Z, RotZ)
end

function Ability_Task_Summons:DoBasedOnPoint(Context, SummonID, SummonMaster, Pos, RotZ, SocketName)
    print("SocketName is ", SocketName)
    local Owner = Context:GetOwner()
    print("Owner is ", Owner)
    local Summon = SPGameSummonManager:SpawnOneSummon(SummonID, SummonMaster, Context, Pos.X, Pos.Y, Pos.Z, RotZ)
    print("Summon is ", Summon)
    Summon:K2_AttachToComponent(Owner.Mesh, SocketName, UE4.EAttachmentRule.SnapToTarget, UE4.EAttachmentRule.SnapToTarget, UE4.EAttachmentRule.SnapToTarget, false)

    if not self.AttachToSocket then
        Summon:K2_DetachFromActor(UE4.EAttachmentRule.KeepWorld, UE4.EAttachmentRule.KeepWorld, UE4.EAttachmentRule.KeepWorld)
    else
        local Location = self.AttackSocketOffset
        local Transform = UE4.FTransform(UE4.FQuat(), Location, self.Scale3D)
        Summon:K2_SetActorRelativeTransform(Transform)
    end

    return Summon
end

function Ability_Task_Summons:DoBasedOnRange(Context, SummonID, SummonMaster, Pos, RotZ)
    local EndX, EndY
    if not self.UseRectangleSpawnRange then
        local HalfEdge = self.WayThreeHalfEdge
        EndX, EndY = self:GenerateRandomPosInCircle(Pos, HalfEdge)
    else
        local HalfExtentX = self.RectangleSpawnRange.X
        local HalfExtentY = self.RectangleSpawnRange.Y
        EndX, EndY = self:GenerateRandomPosInRectangle(Pos, HalfExtentX, HalfExtentY)
    end
    local FinalPos = UE4.FVector(EndX, EndY, Pos.Z)
    return SPGameSummonManager:SpawnOneSummon(SummonID, SummonMaster, Context, FinalPos.X, FinalPos.Y, FinalPos.Z, RotZ)
end

function Ability_Task_Summons:GenerateRandomPosInCircle(CenterPoint, Radius)
    local randomseed = tostring(os.clock()):reverse():sub(1, 6)
    math.randomseed(tonumber(randomseed) * 100)
    -- 生成随机角度
    local angle = math.random() * 2 * math.pi
    -- 生成随机半径
    local radius = math.sqrt(math.random()) * Radius

    -- 转换为笛卡尔坐标
    local x = CenterPoint.X + radius * math.cos(angle)
    local y = CenterPoint.Y + radius * math.sin(angle)

    return x , y
end

function Ability_Task_Summons:GenerateRandomPosInRectangle(CenterPoint, HalfExtentX, HalfExtentY)
    local randomseed = tostring(os.clock()):reverse():sub(1, 6)
    math.randomseed(tonumber(randomseed) * 100)

    local CenterPos = UE4.FVector(math.floor(CenterPoint.X), math.floor(CenterPoint.Y), CenterPoint.Z)

    local RandomX = math.random(CenterPos.X - HalfExtentX, CenterPos.X + HalfExtentX)
    local RandomY = math.random(CenterPos.Y - HalfExtentY, CenterPos.Y + HalfExtentY)
    return RandomX , RandomY
end

function Ability_Task_Summons:DoBasedOnDirection(Context, SummonID, SummonMaster, Pos, RotZ)
    local Owner = Context:GetOwner()
    local Forward = Owner:GetActorForwardVector()
    local ImpactFactor = 500
    local FinalPos = Pos + Forward * ImpactFactor

    return SPGameSummonManager:SpawnOneSummon(SummonID, SummonMaster, Context, FinalPos.X, FinalPos.Y, FinalPos.Z, RotZ)
end

function Ability_Task_Summons:DoBasedOnTarget(Context, SummonID, SummonMaster, Pos, RotZ)
    local TargetLocation = Context:GetTargetLocation()
    return SPGameSummonManager:SpawnOneSummon(SummonID, SummonMaster, Context, TargetLocation.X, TargetLocation.Y, TargetLocation.Z, RotZ)
end

function Ability_Task_Summons:DoBasedOnBlackBoardKey(Context, SummonID, SummonMaster, Pos, RotZ)
    local TargetLocation = Context:GetTargetLocation()
    local OwnerActor = Context:GetOwner()
    local Blackboard = UE4.UAIBlueprintHelperLibrary.GetBlackboard(OwnerActor)
    if Blackboard ~= nil then
        local TargetActor = Blackboard:GetValueAsObject(self.SpawnBlackBoardKey)
        if _SP.IsValid(TargetActor) then
            local summon = SPGameSummonManager:SpawnOneSummon(SummonID, SummonMaster, Context, TargetLocation.X, TargetLocation.Y, TargetLocation.Z, RotZ)
            summon:ClearTargetActors()
            summon:AddTargetActor(TargetActor)
            return summon
        end
    end
end

function Ability_Task_Summons:DoBasedOnFoundTargetsLocation(SummonNum, Context, SummonID, SummonMaster, Pos, RotZ)
    local FoundTargets = self.FoundTargets
    if not FoundTargets or #FoundTargets < 1 or SummonNum < 1 then
        return
    end

    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad then
        return
    end

    for _, value in pairs(self.FoundTargets) do
        if SummonNum > 0 then
            SummonNum = SummonNum - 1
        else
            return
        end

        local canSummon = true
        if self.UseLimitOnceSummon then
            if ScratchPad.HasBeenGeneratedTargetList[value:GetUID()] then
                canSummon = false
            else
                ScratchPad.HasBeenGeneratedTargetList[value:GetUID()] = true
            end
        end

        if canSummon then
            if self.EnableSummonTargetBuffCheck == true then
                local abilityComponent = value:GetAbilityComponent()
                if _SP.IsValid(abilityComponent) and not abilityComponent:HaveBuff(self.CheckBuffID) then
                    local TargetLocation = value:K2_GetActorLocation()
                    local summon = SPGameSummonManager:SpawnOneSummon(SummonID, SummonMaster, Context, TargetLocation.X, TargetLocation.Y, TargetLocation.Z, RotZ)
                    summon.BuffID = self.CheckBuffID
                    summon:ClearTargetActors()
                    summon:AddTargetActor(value)
                    self:InheritAllPositiveBuffsFromSummoner(Context, summon)
                end
            else
                local TargetLocation = value:K2_GetActorLocation()
                local summon = SPGameSummonManager:SpawnOneSummon(SummonID, SummonMaster, Context, TargetLocation.X, TargetLocation.Y, TargetLocation.Z, RotZ)
                summon:ClearTargetActors()
                summon:AddTargetActor(value)
                self:InheritAllPositiveBuffsFromSummoner(Context, summon)
            end
        end
    end
end

function Ability_Task_Summons:GetTaskRealmBP()
    return UE4.EAbleAbilityTaskRealm.ATR_Server
end

function Ability_Task_Summons:GetTaskScratchPadClassBP(Context)
    return SPAbilityUtils.LoadScratchPadClass(SPAbility.ScratchPadClass.Summons)
end

------------- Fix summon's spawning transform -------------

function Ability_Task_Summons:GetFixedTransformAfterSpawning(Context, OriginTransform)
    local ResultTransform = OriginTransform;

    -- First to fix the orientation
    if self.FixOrientationAfterSpawningPolicy == UE4.ESPFixOrientationAfterSummonSpawned.FaceToTarget then
        if Context:GetTargetActors() then
            local TargetActor = Context:GetTargetActors():Get(1)
            if TargetActor then
                ResultTransform = self:FixOrientationAfterSpawning(OriginTransform, TargetActor)
            end
        end
    elseif self.FixOrientationAfterSpawningPolicy == UE4.ESPFixOrientationAfterSummonSpawned.FaceToOwner then
        local OwnerActor = Context:GetOwner()
        if OwnerActor then
            ResultTransform = self:FixOrientationAfterSpawning(OriginTransform, OwnerActor)
        end
    elseif self.FixOrientationAfterSpawningPolicy == UE4.ESPFixOrientationAfterSummonSpawned.RandomFacing then
        local TargetActor = Context:GetOwner()
        if TargetActor then
            ResultTransform = self:FixOrientationAfterSpawning(OriginTransform, TargetActor)
        end

        local RandomRotation = UE4.FRotator()
        RandomRotation.Yaw =  UE4.UKismetMathLibrary.RandomFloatInRange(self.RandomFacingRangeMin.X, self.RandomFacingRangeMax.X)
        RandomRotation.Pitch =  UE4.UKismetMathLibrary.RandomFloatInRange(self.RandomFacingRangeMin.Y, self.RandomFacingRangeMax.Y)
        RandomRotation.Roll =  UE4.UKismetMathLibrary.RandomFloatInRange(self.RandomFacingRangeMin.Z, self.RandomFacingRangeMax.Z)

        ResultTransform.Rotation = ResultTransform.Rotation * RandomRotation:ToQuat()
    end

    if self.FixedTransformOffsetAfterSpawning then
        ResultTransform = UE4.UKismetMathLibrary.ComposeTransforms(OriginTransform, self.FixedTransformOffsetAfterSpawning)
    end

    -- Fix location after all transform parmas are all set!!
    if self.FixSpawnLocationIfCollide and self.FixSpawnLocationIfCollide == true and self.AcceptableSpawnRadiusIfCollide then
        ResultTransform =  self:GetFixedSpawnLocationIfCollide(Context, ResultTransform)
    end

    if self.ConstraintRollAfterSpawned or self.ConstraintPitchAfterSpawned or self.ConstraintYawAfterSpawned then
        local NewRotation = ResultTransform.Rotation:ToRotator()
        if self.ConstraintRollAfterSpawned then
            NewRotation.Roll = 0;
        end
        if self.ConstraintPitchAfterSpawned then
            NewRotation.Pitch = 0;
        end
        if self.ConstraintYawAfterSpawned then
            NewRotation.Yaw = 0;
        end
        ResultTransform.Rotation = NewRotation:ToQuat()
    end

    return ResultTransform
end

function Ability_Task_Summons:FixOrientationAfterSpawning(OriginTransform, TargetActor)
    if TargetActor then
        local FixedOrientation = UE4.UKismetMathLibrary.FindLookAtRotation(OriginTransform.Translation, TargetActor:K2_GetActorLocation())
        OriginTransform.Rotation = FixedOrientation:ToQuat()
    end

    return OriginTransform
end

------------- ~End of Fix summon's spawning transform -------------

function Ability_Task_Summons:GetFixedSpawnLocationIfCollide(Context, OriginTransform)
    local NavData = UE4.USPUtilityLibrary.GetNavigationData(_SP.GetCurrentWorld());
    local QueryObjectsArray = UE4.TArray(UE4.EObjectTypeQuery)
    QueryObjectsArray:Add(UE4.UMoeBlueprintLibrary.ConvertToObjectType(UE4.ECollisionChannel.ECC_WorldStatic))
    local IgnoreActors = UE4.TArray(UE4.AActor)
    local DrawDebugType = UE4.EDrawDebugTrace.None
    if UE4.USPAbilityFunctionLibrary.IsVerboseDebug() then
        DrawDebugType = UE4.EDrawDebugTrace.ForDuration
    end

    if NavData then
        for i = 1, 20 do
            local FixedResultLocation, bResult = UE4.UNavigationSystemV1.K2_GetRandomLocationInNavigableRadius(_SP.GetCurrentWorld(), OriginTransform.Translation, nil, self.AcceptableSpawnRadiusIfCollide, NavData)
            if bResult then
                local CheckLineHitResult, bHasLineCollide = UE4.UKismetSystemLibrary.LineTraceMultiForObjects(
                    Context:GetOwner(),
                    Context:GetOwner():K2_GetActorLocation(),
                    FixedResultLocation,
                    QueryObjectsArray,
                    false,
                    IgnoreActors,
                    DrawDebugType,
                    nil,
                    true,
                    UE4.FLinearColor.Red,
                    UE4.FLinearColor.Green,
                    10 --[[DrawTime]]
                )
                if not bHasLineCollide then
                    -- generate a capsule collision check if this location is standable for character.
                    local CheckHitResult, bHasCollide = UE4.UKismetSystemLibrary.CapsuleTraceSingle(
                        Context:GetOwner(), --[[WorldContextObject]]
                        FixedResultLocation, --[[Start]]
                        FixedResultLocation+  UE4.FVector(0, 0, 1), --[[End]]
                        80, --[[Radius]]
                        200, --[[HalfHeight]]
                        QueryObjectsArray, --[[ObjectTypes]]
                        false, --[[bTraceComplex]]
                        IgnoreActors, --[[ActorsToIgnore]]
                        DrawDebugType, --[[DrawDebugType]]
                        nil, --[[OutHits]]
                        true, --[[bIgnoreSelf]]
                        UE4.FLinearColor.Red,
                        UE4.FLinearColor.Green,
                        10 --[[DrawTime]]
                    )

                    if not bHasCollide then
                        OriginTransform.Translation = FixedResultLocation
                        -- OriginTransform.Rotation = CheckHitResult.Normal:ToQuat():ToRotator()
                        return OriginTransform
                    end
                end
            end
        end
    end

    return OriginTransform
end

function Ability_Task_Summons:FindPlayerNumBySearchRadius(Context)
    local PlayerNum = 0
    local Owner = Context:GetOwner()
    local SelftLocation = Owner:K2_GetActorLocation()
    local queryTypeList = UE4.TArray(UE4.EObjectTypeQuery)
    local OutActors

    -- 如果开启了检测目标Capsule则进行设置对应通道进行碰撞通道检测
    if self.DetectTargetCapsule then
        -- 检测玩家胶囊体通道
        queryTypeList:Add(UE4.UMoeBlueprintLibrary.ConvertToObjectType(UE4.ECollisionChannel.ECC_Pawn))
        -- 检测野生星兽和宠物胶囊体通道
        queryTypeList:Add(UE4.UMoeBlueprintLibrary.ConvertToObjectType(UE4.USPGameLibrary.GetCollisionChannelBySPTraceType(UE4.ESPTraceType.WildMonster)))
        queryTypeList:Add(UE4.UMoeBlueprintLibrary.ConvertToObjectType(UE4.USPGameLibrary.GetCollisionChannelBySPTraceType(UE4.ESPTraceType.CallMonster)))
    end

    OutActors = UE4.UKismetSystemLibrary.SphereOverlapActors(
        _SP.GetCurrentWorld(),
        SelftLocation,
        self.SearchRadius,
        queryTypeList,
        UE4.AMoeCharacter.StaticClass()
    )

    self.FoundTargets = {}

    local ActorNum = OutActors:Length()
    for index = 1, ActorNum do
        local TargetActor = OutActors:Get(index)

        if self.TargetPlayer
                and TargetActor:Cast(UE4.ASPGameCharacterBase.StaticClass())
                and not TargetActor:GetIsDead()
                and self:IsPlayerTeam(TargetActor) then
            PlayerNum = PlayerNum + 1
            table.insert(self.FoundTargets, TargetActor)

        end

        if self.TargetPet
                and TargetActor:Cast(UE4.ASPGameMonsterBase.StaticClass())
                and not TargetActor:GetIsDead()
                and self:IsPlayerTeam(TargetActor) then
            PlayerNum = PlayerNum + 1
            table.insert(self.FoundTargets, TargetActor)
        end

    end

    return PlayerNum
end

function Ability_Task_Summons:IsPlayerTeam(TargetActor)
    if not TargetActor.GetSPTeamID then
        return false
    end

    ---判断是不是玩家阵营
    local teamID = TargetActor:GetSPTeamID()
    return teamID ~= 0 and teamID <= 100
end

function Ability_Task_Summons:ResetScratchPadBP(ScratchPad)
    if ScratchPad then
        ScratchPad.HasBeenGeneratedTargetList = {}
        ScratchPad.GenerateTimer = 0
        ScratchPad.PointInRangeList = {}
        ScratchPad.SummonElapsedTime = nil

    end
end

return Ability_Task_Summons