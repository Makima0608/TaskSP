---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by byteyang.
--- DateTime: 2024/12/23 21:48
---

local SPAbilityUtils = require("Feature.StarP.Script.System.Ability.SPAbilityUtils")
local SPAbility = require("Feature.StarP.Script.System.Ability.SPAbilityClasses")

local IsValid = _SP.IsValid
local math_max = math.max
local ipairs = ipairs
local tonumber = tonumber
local string_format = string.format
local table_insert = table.insert
local CommonUtils = _SPFeature.Utils.CommonUtils

local function Log(...)
    -- todo... 先把这个注掉，lua这边我v7加个全局变量来判断verbose
    -- _SP.Log("SPAbility", "[Ability_Task_CollisionDamage]", ...)
end

local function Warning(...)
    _SP.LogWarning("SPAbility", "[Ability_Task_CollisionDamage]", ...)
end

local function Error(...)
    _SP.LogError("SPAbility", "[Ability_Task_CollisionDamage]", ...)
end

---@class FAbilityShapeRange
---@field HalfExtents FVector
---@field Radius float
---@field HalfHeight float
---@field ConeRadius float
---@field ConeLength float
---@field CylinderInnerRadius float
---@field CylinderOuterRadius float
---@field CylinderHeight float
---@field CylinderAngle float

---@class Ability_Task_CollisionDamage : USPAbilityTask
---@field ShapeRange FAbilityShapeRange
local Ability_Task_CollisionDamage = UE4.Class(nil, "Ability_Task_CollisionDamage")

function Ability_Task_CollisionDamage:OnTaskStartBP(Context)
    ---@type Ability_Task_CollisionDamagePad
    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad then
        Warning("[OnTaskStartBP]", "ScratchPad is nil")
        return
    end

    -- 清空伤害计数
    Context:SetIntParameter("DamageCount", 0)

    -- 初始化ScratchPad数据
    if not ScratchPad.t_cache then
        ScratchPad.t_cache = {}
    end
    local t_cache = ScratchPad.t_cache
    t_cache.DamageMap = {}
    t_cache.BuffMap = {}
    t_cache.Time = self:GetTaskStartTimeBP()
    t_cache.Owner = self:GetSingleActorFromTargetTypeBP(Context, UE4.EAbleAbilityTargetType.ATT_Self)
    t_cache.OwnerActorType = t_cache.Owner.GetSPActorType and t_cache.Owner:GetSPActorType()
    t_cache.Instigator = Context:GetInstigator() or t_cache.Owner
    t_cache.AbilityId = Context:GetAbilityId()
    t_cache.AbilityUniqueID = Context:GetAbilityUniqueID()
    t_cache.bInterrupt = false
    t_cache.bDamage = true
    t_cache.bCanThisCollisionTriggerDodge = true
    t_cache.RangeUpdateIntervalControlTime = 0
    t_cache.HighPingPawns = Context:GetHighPingPawns()

    -- Log("[OnTaskStartBP]", "AbilityId:", ScratchPad.AbilityId)

    -- 初始化伤害配置
    self:InitDamageConfig(ScratchPad)
    -- 初始化碰撞范围数据
    self:InitShapeRange(ScratchPad)
    -- 计算最大伤害次数
    self:CalcMaxDamageCount(ScratchPad)

    -- 碰撞并伤害
    self:CollisionAndDamage(ScratchPad, Context, true)
end

function Ability_Task_CollisionDamage:OnTaskTickBP(Context, DeltaTime)
    ---@type Ability_Task_CollisionDamagePad
    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad then
       Warning("[OnTaskTickBP]", "ScratchPad is nil")
       return
    end

    local t_cache = ScratchPad.t_cache
    --计算时间
    t_cache.Time = t_cache.Time + DeltaTime
    t_cache.RangeUpdateIntervalControlTime = t_cache.RangeUpdateIntervalControlTime + DeltaTime

    -- 碰撞并伤害
    self:CollisionAndDamage(ScratchPad, Context)
end

function Ability_Task_CollisionDamage:OnTaskEndBP(Context, Result)
    ---@type Ability_Task_CollisionDamagePad
    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad then
        Warning("[OnTaskEndBP]", "ScratchPad is nil")
        return
    end

    ScratchPad.t_cache.Time = self:GetTaskEndTimeBP()

    if not self:IsSingleFrameBP() and
            Result == UE4.EAbleAbilityTaskResult.Successful then
        -- 碰撞并伤害
        self:CollisionAndDamage(ScratchPad, Context)
    end

    -- 清理ScratchPad数据(回池会自动清理不需要主动调用)
    -- self:ClearScratchPad(ScratchPad)
end

---@param ScratchPad Ability_Task_CollisionDamagePad
function Ability_Task_CollisionDamage:ResetScratchPadBP(ScratchPad)
    -- 清理ScratchPad数据
    self:ClearScratchPad(ScratchPad)
end

---@param ScratchPad Ability_Task_CollisionDamagePad
function Ability_Task_CollisionDamage:ClearScratchPad(ScratchPad)
    -- ScratchPad.DamageMap = nil
    -- ScratchPad.BuffMap = nil
    -- ScratchPad.Time = nil
    -- ScratchPad.Owner = nil
    -- ScratchPad.OwnerActorType = nil
    -- ScratchPad.Instigator = nil
    -- ScratchPad.AbilityId = nil
    -- ScratchPad.AbilityUniqueID = nil
    -- ScratchPad.bInterrupt = nil
    -- ScratchPad.bDamage = nil
    -- ScratchPad.bCanThisCollisionTriggerDodge = nil
    -- ScratchPad.RangeUpdateIntervalControlTime = nil
    -- ScratchPad.HighPingPawns = nil
    -- ScratchPad.DamageConfig = nil
    -- ScratchPad.HitConfig = nil
    -- ScratchPad.Orientation = nil
    -- ScratchPad.HitResults = nil
    -- ScratchPad.DamageResults = nil
    -- ScratchPad.OwnerSummonMaster = nil
    -- ScratchPad.CacheTeamRelation = {}
    -- ScratchPad.ShapeRange = nil
    -- ScratchPad.BranchSegmentObstacle = nil
    ScratchPad.t_cache = {
        DamageMap = nil,
        BuffMap = nil,
        Time = nil,
        Owner = nil,
        OwnerActorType = nil,
        Instigator = nil,
        AbilityId = nil,
        AbilityUniqueID = nil,
        bInterrupt = nil,
        bDamage = nil,
        bCanThisCollisionTriggerDodge = nil,
        RangeUpdateIntervalControlTime = nil,
        HighPingPawns = nil,
        DamageConfig = nil,
        HitConfig = nil,
        Orientation = nil,
        HitResults = nil,
        DamageResults = nil,
        OwnerSummonMaster = nil,
        CacheTeamRelation = {},
        ShapeRange = nil,
        BranchSegmentObstacle = nil
    }
end

function Ability_Task_CollisionDamage:GetTaskScratchPadClassBP(Context)
    return SPAbilityUtils.LoadScratchPadClass(SPAbility.ScratchPadClass.CollisionDamage)
end

---InitDamageConfig
---初始化伤害配置
---@param ScratchPad Ability_Task_CollisionDamagePad
function Ability_Task_CollisionDamage:InitDamageConfig(ScratchPad)
    local t_cache = ScratchPad.t_cache
    local DamageId = 0
    if self.DamageId == -1 then
        local AbilityId = t_cache.AbilityId
        local abilityData = _SP.SPGameplayUtils:GetSkillData(AbilityId)
        if abilityData then
            local DamageIds = abilityData.damageIds or {}
            DamageId = tonumber(DamageIds[self.DamageIndex + 1])
            if DamageId == nil then
                Warning("Ability Damage Config Error ", string_format("Ability [%s] config DamageIndex [%s], damage list length = [%s]", AbilityId, self.DamageIndex, #DamageIds))
                DamageId = -1
            end
        end
    else
        DamageId = self.DamageId
    end

    t_cache.DamageId = DamageId
    t_cache.DamageConfig = _SP.SPConfigManager:GetConfigById("SPDamageConfigTable", "SPDamageConfig", DamageId)
    local HitId = t_cache.DamageConfig and t_cache.DamageConfig.hitId or 0
    t_cache.HitConfig = _SP.SPConfigManager:GetConfigById("SPHitConfigTable", "SPHitConfig", HitId)
end

---InitShapeRange
---初始化碰撞范围数据
---@param ScratchPad Ability_Task_CollisionDamagePad
function Ability_Task_CollisionDamage:InitShapeRange(ScratchPad)
    local t_cache = ScratchPad.t_cache
    if not self.bUpdateVelocity and not self.AdaptOwnerScale then
        -- 封装一个LuaTable 防止一直访问Struct导致的GetUProperty开销
        local ShapeRange = {
            HalfExtents = self.ShapeRange.HalfExtents,
            Radius = self.ShapeRange.Radius,
            HalfHeight = self.ShapeRange.HalfHeight,
            ConeRadius = self.ShapeRange.ConeRadius,
            ConeLength = self.ShapeRange.ConeLength,
            CylinderInnerRadius = self.ShapeRange.CylinderInnerRadius,
            CylinderOuterRadius = self.ShapeRange.CylinderOuterRadius,
            CylinderHeight = self.ShapeRange.CylinderHeight,
            CylinderAngle = self.ShapeRange.CylinderAngle,
            CylinderInitialOuterRadius = self.ShapeRange.CylinderOuterRadius,
        }
        t_cache.ShapeRange = ShapeRange
        return
    end
    ---@type FAbilityShapeRange
    local ShapeRange = {
        HalfExtents = self.ShapeRange.HalfExtents,
        Radius = self.ShapeRange.Radius,
        HalfHeight = self.ShapeRange.HalfHeight,
        ConeRadius = self.ShapeRange.ConeRadius,
        ConeLength = self.ShapeRange.ConeLength,
        CylinderInnerRadius = self.ShapeRange.CylinderInnerRadius,
        CylinderOuterRadius = self.ShapeRange.CylinderOuterRadius,
        CylinderHeight = self.ShapeRange.CylinderHeight,
        CylinderAngle = self.ShapeRange.CylinderAngle,
        CylinderInitialOuterRadius = self.ShapeRange.CylinderOuterRadius,
        CylinderChangeOuterRadius = self.CylinderMaxOuterRadius - self.ShapeRange.CylinderOuterRadius
    }

    -- 如果配置的最大外环Radius为负数，则以要向内缩放到0处理
    if self.CylinderMaxOuterRadius < 0 then
        ShapeRange.CylinderChangeOuterRadius = -self.ShapeRange.CylinderOuterRadius
    end

    -- 是否跟随释放者的缩放跳转伤害范围
    if self.AdaptOwnerScale then
        local Owner = t_cache.Owner
        if IsValid(Owner) then
            local OwnerScale = Owner:GetActorScale3D()
            if self.CollisionShape == SPAbilityUtils.EAbilityCollisionShape.Box then
                -- 如果是Box，根据Scale信息分别缩放XYZ即可
                ShapeRange.HalfExtents = ShapeRange.HalfExtents * OwnerScale
            elseif self.CollisionShape == SPAbilityUtils.EAbilityCollisionShape.Sphere then
                -- 如果是Sphere，更具Scale信息中最大值缩放Radius
                local MaxScaleValue = math_max(OwnerScale.X, OwnerScale.Y, OwnerScale.Z)
                ShapeRange.Radius = ShapeRange.Radius * MaxScaleValue
            elseif self.CollisionShape == SPAbilityUtils.EAbilityCollisionShape.Capsule then
                -- 如果是Capsule，那么Scale的XY影响Radius，Z值影响HalfHeight
                local MaxHorizontalScaleValue = math_max(OwnerScale.X, OwnerScale.Y)
                ShapeRange.Radius = ShapeRange.Radius * MaxHorizontalScaleValue
                ShapeRange.HalfHeight = ShapeRange.HalfHeight * OwnerScale.Z
            elseif self.CollisionShape == SPAbilityUtils.EAbilityCollisionShape.Cone then
                -- 如果是Cone，默认预览中，XZ控制Raidus，Y控制Length
                local MaxVerticalScaleValue = math_max(OwnerScale.X, OwnerScale.Z)
                ShapeRange.ConeRadius = ShapeRange.ConeRadius * MaxVerticalScaleValue
                ShapeRange.ConeLength = ShapeRange.ConeLength * OwnerScale.Y
            elseif self.CollisionShape == SPAbilityUtils.EAbilityCollisionShape.Cylinder then
                -- 如果是Cylinder，XY影响Radius，Z影响Height，Angle不受影响
                local MaxHorizontalScaleValue = math_max(OwnerScale.X, OwnerScale.Y)
                ShapeRange.CylinderInnerRadius = ShapeRange.CylinderInnerRadius * MaxHorizontalScaleValue
                ShapeRange.CylinderOuterRadius = ShapeRange.CylinderOuterRadius * MaxHorizontalScaleValue
                ShapeRange.CylinderHeight = ShapeRange.CylinderHeight * OwnerScale.Z
                ShapeRange.CylinderInitialOuterRadius = self.CylinderMaxOuterRadius
                local ScaledCylinderMaxOuterRadius = self.CylinderMaxOuterRadius * MaxHorizontalScaleValue
                ShapeRange.CylinderChangeOuterRadius = ScaledCylinderMaxOuterRadius - self.ShapeRange.CylinderOuterRadius
            end
        end
    end

    t_cache.ShapeRangeBase = ShapeRange
    t_cache.ShapeRange = CommonUtils:DeepCopy(ShapeRange)
end

---CalcMaxDamageCount
---计算最大伤害次数
---@param ScratchPad Ability_Task_CollisionDamagePad
function Ability_Task_CollisionDamage:CalcMaxDamageCount(ScratchPad)
    local t_cache = ScratchPad.t_cache
    local Owner = t_cache.Owner
    local AbilityId = t_cache.AbilityId
    local AbilityUniqueID = t_cache.AbilityUniqueID

    SPAbilityUtils.DispatchMaxDamageCount(AbilityId, AbilityUniqueID, Owner, self.DamageMaxCount, self.DamageInterval, self:GetDuration())
end

---CollisionAndDamage
---碰撞并伤害
---@param ScratchPad Ability_Task_CollisionDamagePad
---@param Context UAbleAbilityContext
function Ability_Task_CollisionDamage:CollisionAndDamage(ScratchPad, Context, bStart)
    -- 更新碰撞范围数据
    self:UpdateShapeRange(ScratchPad)
    -- 碰撞检测
    self:DoCollision(ScratchPad, Context, bStart)
    -- 造成伤害
    self:DoDamage(ScratchPad, Context)

    self:PrintDsCollisionMessageOnScreen(ScratchPad)
end

---UpdateShapeRange
---更新碰撞范围数据
---@param ScratchPad Ability_Task_CollisionDamagePad
function Ability_Task_CollisionDamage:UpdateShapeRange(ScratchPad)
    if not self.bUpdateVelocity then
        return
    end
    local t_cache = ScratchPad.t_cache
    if self.UseCustomRangeUpdateInterval and self.CustomRangeUpdateInterval > 0 then
        -- 使用自定义更新间隔
        if t_cache.RangeUpdateIntervalControlTime < self.CustomRangeUpdateInterval then
            return
        else
            t_cache.RangeUpdateIntervalControlTime = 0
        end
    end
    local ShapeRangeBase = t_cache.ShapeRangeBase
    local ShapeRange = t_cache.ShapeRange

    local CurrTime = t_cache.Time - self:GetTaskStartTimeBP()

    if CurrTime == 0 then
        return
    end

    if self.CollisionShape == SPAbilityUtils.EAbilityCollisionShape.Box then
        if self.ExtendsXUpdateTime > 0 then
            local Percent = CurrTime / self.ExtendsXUpdateTime
            if Percent > 1 then Percent = 1 end
            local ChangeExtendX = Percent * self.ExtendsXUpdateVelocity
            ShapeRange.HalfExtents.X =  ShapeRangeBase.HalfExtents.X + ChangeExtendX
        else
            -- ExtendsXUpdateTime配置为负数时匀速增加
            ShapeRange.HalfExtents.X =  ShapeRangeBase.HalfExtents.X + self.ExtendsXUpdateVelocity
        end
        if self.ExtendsYUpdateTime > 0 then
            local Percent = CurrTime / self.ExtendsYUpdateTime
            if Percent > 1 then Percent = 1 end
            local ChangeExtendY = Percent * self.ExtendsYUpdateVelocity
            ShapeRange.HalfExtents.Y =  ShapeRangeBase.HalfExtents.Y + ChangeExtendY
        else
            -- ExtendsYUpdateVelocity配置为负数时匀速增加
            ShapeRange.HalfExtents.Y =  ShapeRangeBase.HalfExtents.Y + self.ExtendsYUpdateVelocity
        end
        if self.ExtendsZUpdateTime > 0 then
            local Percent = CurrTime / self.ExtendsZUpdateTime
            if Percent > 1 then Percent = 1 end
            local ChangeExtendZ = Percent * self.ExtendsZUpdateVelocity
            ShapeRange.HalfExtents.Z =  ShapeRangeBase.HalfExtents.Z + ChangeExtendZ
        else
            -- ExtendsZUpdateVelocity配置为负数时匀速增加
            ShapeRange.HalfExtents.Z =  ShapeRangeBase.HalfExtents.Z + self.ExtendsZUpdateVelocity
        end
    elseif self.CollisionShape == SPAbilityUtils.EAbilityCollisionShape.Sphere then
        if self.RadiusUpdateTime > 0 then
            local Percent = CurrTime / self.RadiusUpdateTime
            if Percent > 1 then Percent = 1 end
            local ChangeRadius = CurrTime / self.RadiusUpdateTime * self.RadiusUpdateVelocity
            ShapeRange.Radius =  ShapeRangeBase.Radius + ChangeRadius
        else
            -- RadiusUpdateVelocity配置为负数时匀速增加
            ShapeRange.Radius =  ShapeRangeBase.Radius + self.RadiusUpdateVelocity
        end
    elseif self.CollisionShape == SPAbilityUtils.EAbilityCollisionShape.Capsule then
        if self.HeightUpdateTime > 0 then
            local Percent = CurrTime / self.HeightUpdateTime
            if Percent > 1 then Percent = 1 end
            local ChangeRadiusHeight = Percent * self.HeightUpdateVelocity
            ShapeRange.HalfHeight =  ShapeRangeBase.HalfHeight + ChangeRadiusHeight
        else
            -- HeightUpdateVelocity配置为负数时匀速增加
            ShapeRange.HalfHeight =  ShapeRangeBase.HalfHeight + self.HeightUpdateVelocity
        end
        if self.RadiusUpdateTime > 0 then
            local Percent = CurrTime / self.RadiusUpdateTime
            if Percent > 1 then Percent = 1 end
            local ChangeRadius = Percent * self.RadiusUpdateVelocity
            ShapeRange.Radius =  ShapeRangeBase.Radius + ChangeRadius
        else
            -- RadiusUpdateVelocity配置为负数时匀速增加
            ShapeRange.Radius =  ShapeRangeBase.Radius + self.RadiusUpdateVelocity
        end
    elseif self.CollisionShape == SPAbilityUtils.EAbilityCollisionShape.Cylinder then
        if self.CylinderRadiusUpdateTime > 0 then
            local Percent = CurrTime / self.CylinderRadiusUpdateTime
            if Percent > 1 then Percent = 1 end
            local ChangeCylinderRadius = Percent * ShapeRange.CylinderChangeOuterRadius
            -- 圆柱的Update需要考虑上一次的外环，不然会导致“跳环”情况
            ShapeRange.CylinderInnerRadius = ShapeRange.CylinderOuterRadius
            ShapeRange.CylinderOuterRadius = ShapeRange.CylinderInitialOuterRadius + ChangeCylinderRadius
        else
            -- CylinderRadiusUpdateVelovity配置为负数时匀速增加
            ShapeRange.CylinderInnerRadius = ShapeRange.CylinderInnerRadius + self.CylinderRadiusUpdateVelovity
            ShapeRange.CylinderOuterRadius = ShapeRange.CylinderOuterRadius + self.CylinderRadiusUpdateVelovity
        end
        if self.CylinderHeightUpdateTime > 0 then
            local Percent = CurrTime / self.CylinderHeightUpdateTime
            if Percent > 1 then Percent = 1 end
            local ChangeCylinderHeight = Percent * self.CylinderHeightUpdateVelocity
            ShapeRange.CylinderHeight = ShapeRange.CylinderHeight + ChangeCylinderHeight
        else
            -- CylinderHeightUpdateVelocity配置为负数时匀速增加
            ShapeRange.CylinderHeight = ShapeRange.CylinderHeight + self.CylinderHeightUpdateVelocity
        end
    end
end

---DoCollision
---碰撞检测
---@param ScratchPad Ability_Task_CollisionDamagePad
---@param Context UAbleAbilityContext
---@param bStart bool
function Ability_Task_CollisionDamage:DoCollision(ScratchPad, Context, bStart)
    if not Context then
        return
    end
    local t_cache = ScratchPad.t_cache
    local Owner = t_cache.Owner
    if not IsValid(Owner) then
        Warning("[DoCollision]", "Owner is nil")
        return
    end

    local TraceStart = nil
    local Orientation = nil

    if not self.bTickCollisionChange and not bStart then
        -- read location and rotation form the ScratchPad
        TraceStart = t_cache.TraceStart or Owner:K2_GetActorLocation()
        Orientation = t_cache.TraceRotation or Owner:K2_GetActorRotation()
    else
        local Transform = UE4.USPAbilityFunctionLibrary.GetAbilityTargetTypeLocationTransform(Context, self.QueryLocation)
        TraceStart = Transform.Translation
        Orientation = Transform.Rotation:ToRotator()
    end
    local ObjectTypes = _SP.SPAbilityUtils.GetObjectTypesPresent(Context, self.CollisionChannelPresent, self.CollisionObjectChannels)

    local HitResults = UE4.TArray(UE4.FHitResult)
    -- 这里使用ScratchPad.ShapeRange来确保Range的更新
    local ShapeRange = t_cache.ShapeRange or self.ShapeRange
    UE4.USPAbilityFunctionLibrary.DoCollisionDetect(Context, Owner, HitResults, self.CollisionShape, ObjectTypes, TraceStart, Orientation, false, ShapeRange.HalfExtents, ShapeRange.Radius, ShapeRange.ConeRadius,
    ShapeRange.ConeLength, ShapeRange.HalfHeight, ShapeRange.CylinderAngle, ShapeRange.CylinderInnerRadius, ShapeRange.CylinderOuterRadius, ShapeRange.CylinderHeight, _SP.IsDSorStandalone and _SP.DS._bShowDebugCollision, self.UseWorldStaticInTypes, self.bIgnoreSelf, self.bUseSweepInDetect)

    t_cache.Orientation = Orientation
    t_cache.HitResults = HitResults

    Log("[DoCollision]", "[DamageDebug]", "AbilityId:", t_cache.AbilityId, "HitResults:", HitResults:Length())

    -- 配置过滤
    UE4.USPAbilityFunctionLibrary.DoCollisionFilterByHitResult(self.Filter.m_Filters, Context, HitResults)

    -- 碰撞过滤
    self:FilterCollision(ScratchPad)

    -- 碰撞效果
    if #t_cache.CollisionResults  > 0 then
        self:CollisionEffect(ScratchPad, Context)
    end
end

---FilterCollision
---碰撞过滤
---@param ScratchPad Ability_Task_CollisionDamagePad
function Ability_Task_CollisionDamage:FilterCollision(ScratchPad)
    -- local HitResults = ScratchPad.HitResults
    -- local CollisionResults = {}

    -- for i = 1, HitResults:Length() do
    --     local HitResult = HitResults:Get(i)

    --     table_insert(CollisionResults, HitResult)

    --     --::continue::
    -- end

    -- ScratchPad.CollisionResults = CollisionResults

    --Log("[CollisionEffect]", "FilterCollision:", #CollisionResults)
    local t_cache = ScratchPad.t_cache
    t_cache.CollisionResults = t_cache.HitResults:ToTable()
end

---CollisionEffect
---碰撞效果
---@param ScratchPad Ability_Task_CollisionDamagePad
---@param Context UAbleAbilityContext
function Ability_Task_CollisionDamage:CollisionEffect(ScratchPad, Context)
    if _SP.IsClientOnly then
        return
    end
    local t_cache = ScratchPad.t_cache
    local CollisionResults = t_cache.CollisionResults
    -- 暂时没有强遍历需求，暂时注释循环遍历（为了减少_index开销）
    local EffectHandle = {}
    ---Interrupt
    if CollisionResults and #CollisionResults > 0 then
        self:CollisionEffect_Interrupt(ScratchPad, Context)
        local BranchSegmentObstacle = t_cache.BranchSegmentObstacle
        if not BranchSegmentObstacle then
            t_cache.BranchSegmentObstacle = self.BranchSegmentMap:Find(_SP.SPAbilityUtils.ESPCollisionActorType.Obstacle) or false
            BranchSegmentObstacle = t_cache.BranchSegmentObstacle
        end
        if BranchSegmentObstacle and BranchSegmentObstacle ~= "None" and BranchSegmentObstacle ~= "" and not t_cache.bInterrupt and self.HitAndBranchSegment then
            table.insert(EffectHandle, "CollisionEffect_Segment")
        end
    end
    if EffectHandle and #EffectHandle > 0 then
        for _, HitResult in ipairs(CollisionResults) do
            for _, handle in pairs(EffectHandle) do
                self[handle](self, HitResult, ScratchPad, Context)
            end
        end
    end
    Log("[CollisionEffect]", "CollisionResults:", #CollisionResults)
end

---CollisionEffect_Interrupt
---碰撞效果_Interrupt
---@param HitResult FHitResult
---@param ScratchPad Ability_Task_CollisionDamagePad
---@param Context UAbleAbilityContext
function Ability_Task_CollisionDamage:CollisionEffect_Interrupt(ScratchPad, Context)
    local t_cache = ScratchPad.t_cache
    if self.ShouldInterrupt and not t_cache.bInterrupt then
        local Owner = t_cache.Owner
        local Instigator = t_cache.Instigator
        local AbilityId = t_cache.AbilityId
        local AbilityComponent = Context:GetSelfAbilityComponent()
        if IsValid(AbilityComponent) then
            t_cache.bInterrupt = true
            AbilityComponent:InterruptedAbility(AbilityId, "interrupt on collision post collision")
            if self.ComboAbilityId ~= 0 then
                AbilityComponent:TryActivateAbility(self.ComboAbilityId, Owner, Instigator, false)
            end
        end
    end
end

local ShouldBranchSegment = function(HitResult, CollisionActorType)
    if CollisionActorType == SPAbilityUtils.ESPCollisionActorType.DamageActor then
        return false
    elseif CollisionActorType == SPAbilityUtils.ESPCollisionActorType.Obstacle then
        -- 先判断是不是worldstatic
        if HitResult then
            local HitComponent = HitResult.Component
            if IsValid(HitComponent) then
                local objectType = HitComponent:GetCollisionObjectType()
                if objectType == UE4.ECollisionChannel.ECC_WorldStatic then
                    return true
                end
            end
        end

        -- 再判断是不是阻挡类召唤物
        local Actor = HitResult.Actor
        if Actor.GetSPActorType then
            if Actor:GetSPActorType() == UE4.ESPActorType.Summon then
                if Actor.UseObstacleCollision then
                    return true
                end
            end
        end
    end
end

---CollisionEffect_Segment
---碰撞效果_Segment
---@param HitResult FHitResult
---@param ScratchPad Ability_Task_CollisionDamagePad
---@param Context UAbleAbilityContext
function Ability_Task_CollisionDamage:CollisionEffect_Segment(HitResult, ScratchPad, Context)
    local t_cache = ScratchPad.t_cache
    local BranchSegmentObstacle = t_cache.BranchSegmentObstacle
    local bBranchSegmentToObstacle = ShouldBranchSegment(HitResult, _SP.SPAbilityUtils.ESPCollisionActorType.Obstacle)
    if bBranchSegmentToObstacle then
        local AbilityComponent = Context:GetSelfAbilityComponent()
        if AbilityComponent:BranchSegmentWithName(Context, BranchSegmentObstacle) then
            t_cache.bInterrupt = true
            Log("[CollisionEffect_Segment]", "DoBranchSegment", BranchSegmentObstacle)
        else
            Warning("[CollisionEffect_Segment]", "DoBranchSegment Failed")
        end
    end
end

---DoDamage
---造成伤害
---@param ScratchPad Ability_Task_CollisionDamagePad
---@param Context UAbleAbilityContext
function Ability_Task_CollisionDamage:DoDamage(ScratchPad, Context)
    local t_cache = ScratchPad.t_cache
    if not t_cache.bDamage then
        return
    end

    -- 伤害过滤
    self:FilterDamage(ScratchPad)

    -- 造成伤害
    local DamageCount = #t_cache.DamageResults
    if DamageCount > 0 then
        -- 造成伤害
        local AbilityDamageComponent = UE4.USPAbilityFunctionLibrary.GetAbilityDamageComponent(t_cache.Instigator)
        if IsValid(AbilityDamageComponent) then
            -- 生成伤害信息
            local DamageInfo = self:GeneratedDamage(ScratchPad, AbilityDamageComponent)

            AbilityDamageComponent:DoDamage(DamageInfo)
        end

        -- 伤害计数
        local SuperimposedDamageCount = Context:GetIntParameter("SuperimposedDamageCount") or 0
        SuperimposedDamageCount = SuperimposedDamageCount + DamageCount
        Context:SetIntParameter("SuperimposedDamageCount", SuperimposedDamageCount)
        Context:SetIntParameter("DamageCount", DamageCount)

        -- 伤害效果
        self:DamageEffect(ScratchPad, Context, t_cache.DamageResults)
    end

    Log("[DoDamage]", "[DamageDebug]", "AbilityId:", t_cache.AbilityId, "DamageId:", t_cache.DamageId, "DamageCount:", DamageCount, "AbilityUniqueID:", t_cache.AbilityUniqueID)
end

---FilterDamage
---过滤伤害
---@param ScratchPad Ability_Task_CollisionDamagePad
function Ability_Task_CollisionDamage:FilterDamage(ScratchPad)
    local t_cache = ScratchPad.t_cache
    local DamageResults = {}
    local CollisionResults = t_cache.CollisionResults

    for _, HitResult in ipairs(CollisionResults) do
        ---间隔时间
        if self:FilterDamage_Interval(HitResult, ScratchPad) then goto continue end
        ---最大次数
        if self:FilterDamage_MaxCount(HitResult, ScratchPad) then goto continue end
        ---死亡
        if self:FilterDamage_Dead(HitResult, ScratchPad) then goto continue end
        ---Actor类型
        if self:FilterDamage_ActorType(HitResult, ScratchPad) then goto continue end

        table_insert(DamageResults, HitResult)

        ::continue::
    end

    t_cache.DamageResults = DamageResults
end

---FilterDamage_Dead
---过滤伤害_死亡
---@param HitResult FHitResult
function Ability_Task_CollisionDamage:FilterDamage_Dead(HitResult)
    local HitActor = HitResult.Actor
    if IsValid(HitActor) then
        if HitActor.GetIsDead and HitActor:GetIsDead() then
            return true
        end
    else
        return true
    end
    return false
end

---FilterDamage_Interval
---过滤伤害_间隔时间
---@param HitResult FHitResult
---@param ScratchPad Ability_Task_CollisionDamagePad
function Ability_Task_CollisionDamage:FilterDamage_Interval(HitResult, ScratchPad)
    local t_cache = ScratchPad.t_cache
    if self.DamageInterval > 0 then
        local HitActor = HitResult.Actor
        if IsValid(HitActor) then
            local DamageMap = t_cache.DamageMap
            local DamageInfo = DamageMap[HitActor]
            if DamageInfo and (t_cache.Time - DamageInfo.DamagedTime) < self.DamageInterval then
                return true
            end
        end
    end
    return false
end

---FilterDamage_MaxCount
---过滤伤害_最大次数
---@param HitResult FHitResult
---@param ScratchPad Ability_Task_CollisionDamagePad
function Ability_Task_CollisionDamage:FilterDamage_MaxCount(HitResult, ScratchPad)
    local t_cache = ScratchPad.t_cache
    if self.DamageMaxCount > 0 then
        local HitActor = HitResult.Actor
        if IsValid(HitActor) then
            local DamageMap = t_cache.DamageMap
            local DamageInfo = DamageMap[HitActor]
            if DamageInfo and DamageInfo.DamagedCount >= self.DamageMaxCount then
                return true
            end
        end
    end
    return false
end

local GetSPActorType = function(HitActor)
    if not IsValid(HitActor) or not HitActor.GetSPActorType then
        return UE4.ESPActorType.None
    end
    return HitActor:GetSPActorType()
end

---FilterDamage_ActorType
---过滤伤害_Actor类型
---@param HitResult FHitResult
---@param ScratchPad Ability_Task_CollisionDamagePad
function Ability_Task_CollisionDamage:FilterDamage_ActorType(HitResult, ScratchPad)
    local HitActor = HitResult.Actor
    -- if HitActor.GetCanBeDamaged and not HitActor:GetCanBeDamaged() then
    --     Log("[FilterDamage_ActorType]", "AbilityId:", ScratchPad.AbilityId, "GetCanBeDamaged")
    --     return true
    -- end
    local t_cache = ScratchPad.t_cache
    if t_cache.OwnerActorType and t_cache.OwnerActorType == UE4.ESPActorType.Summon then
        -- 如果释放碰撞检测的是召唤物，确保召唤物自己的主人不会被自己打
        local Owner = t_cache.Owner
        if t_cache.OwnerSummonMaster == nil then
            if Owner.GetSummonMaster then
                t_cache.OwnerSummonMaster = Owner:GetSummonMaster()
            else
                t_cache.OwnerSummonMaster = false
            end
        end
        if HitActor == t_cache.OwnerSummonMaster then
            Log("[FilterDamage_ActorType]", "AbilityId:", t_cache.AbilityId, "SummonMaster")
            return true
        end
        -- 如果释放碰撞检测的是召唤物，确保召唤物所依附的目标不会受到伤害
        if self.SkipSummonAttachmentActorDamage then
            if Owner.GetAttachParentActor then
                local ParentActor = Owner:GetAttachParentActor()
                if HitActor == ParentActor then
                    Log("[FilterDamage_ActorType]", "AbilityId:", t_cache.AbilityId, "ParentActor")
                    return true
                end
            end
        end
        -- 召唤物也要过滤队友
        if self.bCheckSameTeam then
            if t_cache.CacheTeamRelation[HitActor] == nil then
                t_cache.CacheTeamRelation[HitActor] = UE4.USPGameLibrary.IsInDifferentTeam(t_cache.Owner, HitActor)
            end
            if not t_cache.CacheTeamRelation[HitActor] then
                --Log("[FilterDamage_ActorType]", "AbilityId:", t_cache.AbilityId, "IsInDifferentTeam")
                return true
            end
        end
    else
        if HitActor.GetSPActorType then
            if self.bCheckSameTeam then
                local ActorType = HitActor:GetSPActorType()
                if ActorType == UE4.ESPActorType.Player or ActorType == UE4.ESPActorType.Pet then
                    if t_cache.CacheTeamRelation[HitActor] == nil then
                        t_cache.CacheTeamRelation[HitActor] = UE4.USPGameLibrary.IsInDifferentTeam(t_cache.Owner, HitActor)
                    end
                    if not t_cache.CacheTeamRelation[HitActor] then
                        Log("[FilterDamage_ActorType]", "AbilityId:", t_cache.AbilityId, "IsInDifferentTeam")
                        return true
                    end
                end
            end
        end
    end

    return false
end

---GeneratedDamage
---生成伤害
---@param ScratchPad Ability_Task_CollisionDamagePad
---@param AbilityDamageComponent USPAbilityDamageComponent
function Ability_Task_CollisionDamage:GeneratedDamage(ScratchPad, AbilityDamageComponent)
    local t_cache = ScratchPad.t_cache
    ---@type USPAbilityDamage
    local DamageInfo = UE4.USPAbilityDamage.MakeDamage(AbilityDamageComponent)
    DamageInfo.HighPingPawns = t_cache.HighPingPawns

    local Struct = UE4.FSPAbilityDamageStruct()
    Struct.AbilityId = t_cache.AbilityId
    Struct.DamageId = t_cache.DamageId
    Struct.Owner = t_cache.Owner
    Struct.Instigator = t_cache.Instigator
    Struct.Orientation = t_cache.Orientation
    Struct.UniqueID = t_cache.AbilityUniqueID
    Struct.bForceTrustServer = self.bDamageForceTrustServer or self.HitAndBranchSegment   -- branchSegment需要信任服务器

    local DamageMap = t_cache.DamageMap
    for _, HitResult in ipairs(t_cache.DamageResults) do
        local HitActor = HitResult.Actor
        local Damage = DamageMap[HitActor]
        if not Damage then
            Damage = {
                DamagedCount = 0
            }
            DamageMap[HitActor] = Damage
        end
        Damage.DamagedTime = t_cache.Time
        Damage.DamagedCount = Damage.DamagedCount + 1


        ---@type FSPAbilityDamageResult
        local DamageResult = UE4.FSPAbilityDamageResult()
        DamageResult.HitResult = HitResult

        ---PerfectDodge
        self:GeneratedDamage_PerfectDodge(ScratchPad, DamageResult)
        ---Buff
        self:GeneratedDamage_Buff(ScratchPad, DamageResult)

        Struct.DamageArray:Add(DamageResult)
    end

    DamageInfo:SetStruct(Struct)

    return DamageInfo
end

---GeneratedDamage_Map
---生成伤害_Map
---@param ScratchPad USPAbilityTaskScratchPad
---@param Struct FSPAbilityDamageStruct
function Ability_Task_CollisionDamage:GeneratedDamage_Map(ScratchPad, Struct)
    local t_cache = ScratchPad.t_cache
    local DamageMap = t_cache.DamageMap
    for _, DamageResult in ipairs(t_cache.DamageResults) do
        local HitActor = DamageResult.Actor
        local Damage = DamageMap[HitActor]
        if not Damage then
            Damage = {
                DamagedCount = 0
            }
            DamageMap[HitActor] = Damage
        end
        Damage.DamagedTime = t_cache.Time
        Damage.DamagedCount = Damage.DamagedCount + 1

        Struct.DamageArray:Add(DamageResult)
    end
end

---GeneratedDamage_Buff
---生成伤害_Buff
---@param ScratchPad USPAbilityTaskScratchPad
---@param DamageResult FSPAbilityDamageResult
function Ability_Task_CollisionDamage:GeneratedDamage_Buff(ScratchPad, DamageResult)
    local t_cache = ScratchPad.t_cache
    if self.AddBuffWhenDamage then
        local HitActor = DamageResult.HitResult.Actor
        if not _SP.IsValid(HitActor) then
            return
        end
        if self.bExcludedPlayerBuffAdd and HitActor:GetSPActorType() == UE4.ESPActorType.Player then
            return
        end
        if self.bExcludedMonsterBuffAdd and HitActor:GetSPActorType() == UE4.ESPActorType.Pet then
            return
        end
        if DamageResult.bPerfectDodge then
            return
        end

        local bAddBuff = true
        if not self.AddbuffRepeat then
            if t_cache.BuffMap[HitActor] then
                bAddBuff = false
            else
                t_cache.BuffMap[HitActor] = true
            end
        end
        if bAddBuff then
            DamageResult.BuffId = self.BuffID
            DamageResult.BuffLayer = self.BuffLayer
            DamageResult.bIndexBuffFromSkill = self.IndexBuffFromSkill
            DamageResult.bAddBuffToSource = self.AddBuffToSource

            Log("[GeneratedDamage_Buff]", "BuffID:", self.BuffID)
        end
    end
end

---GeneratedDamage_PerfectDodge
---生成伤害_完美闪避
---@param ScratchPad USPAbilityTaskScratchPad
---@param DamageResult FSPAbilityDamageResult
function Ability_Task_CollisionDamage:GeneratedDamage_PerfectDodge(ScratchPad, DamageResult)
    local t_cache = ScratchPad.t_cache
    local HitActor = DamageResult.HitResult.Actor
    -- 如果是玩家被打 就去完美闪避组件做判断
    if IsValid(HitActor) and HitActor:IsA(UE4.ASPGameCharacterBase) then
        local dmgConfig = _SP.SPConfigManager:GetConfigById("SPDamageConfigTable", "SPDamageConfig", t_cache.DamageId)
        if dmgConfig and dmgConfig.canTriggerPerfectDodge and dmgConfig.canTriggerPerfectDodge > 0 then
            if t_cache.bCanThisCollisionTriggerDodge then
                local PerfectDodgeComponent = HitActor:GetComponentByClass(UE4.USPPerfectDodgeComponent:StaticClass())
                if IsValid(PerfectDodgeComponent) and PerfectDodgeComponent:GetPerfectDodgeCheckTime() then
                    if dmgConfig.canTriggerPerfectDodge == SPAbilityUtils.ESPCollisionTriggerDodgeType.Once then
                        t_cache.bCanThisCollisionTriggerDodge = false
                    end

                    DamageResult.bPerfectDodge = true

                    Log("[DamageEffect_PerfectDodge]", "GeneratedDamage_PerfectDodge")
                end
            end
        end
    end
end

---DamageEffect
---伤害效果
---@param ScratchPad USPAbilityTaskScratchPad
---@param Context UAbleAbilityContext
---@param EffectResults table<FHitResult>
function Ability_Task_CollisionDamage:DamageEffect(ScratchPad, Context, EffectResults)
    local t_cache = ScratchPad.t_cache
    local DamageHandle = {}
    if not _SP.IsClientOnly and self.HitAndBranchSegment and not t_cache.bInterrupt then
        table.insert(DamageHandle, "DamageEffect_Segment")
    end
    if DamageHandle and #DamageHandle > 0 then
        for _, HitResult in ipairs(EffectResults) do
            for _, handle in pairs(DamageHandle) do
                self[handle](self, HitResult, ScratchPad, Context)
            end
        end
    end
end

---DamageEffect_Segment
---伤害效果_Segment
---@param HitResult FHitResult
---@param ScratchPad Ability_Task_CollisionDamagePad
---@param Context UAbleAbilityContext
function Ability_Task_CollisionDamage:DamageEffect_Segment(HitResult, ScratchPad, Context)
    if _SP.IsClientOnly then
        return
    end
    local t_cache = ScratchPad.t_cache
    if self.HitAndBranchSegment and not t_cache.bInterrupt then
        local EffectActor = HitResult.Actor
        if self.bBranchWhenHitTarget then
            local Target = self:GetSingleActorFromTargetTypeBP(Context, UE4.EAbleAbilityTargetType.ATT_TargetActor)
            if EffectActor ~= Target then
                return
            end
        end
        if self.bBranchWhenOnlyHitPlayer and not t_cache.bInterrupt then
            if t_cache.bHitother == true then
                 return
            end
            for _, Result in ipairs(t_cache.DamageResults) do
                if  Result.actor and not Result.actor:IsA(UE4.ASPGameCharacterBase) then
                    t_cache.bHitother = true
                  return
                end
            end
        end
        if Context:GetSelfAbilityComponent():BranchSegmentWithName(Context, self.SegmentName) then
            t_cache.bInterrupt = true
            t_cache.bDamage = false

            Log("[DamageEffect_Segment]", "SegmentName:", self.SegmentName)
        else
            Warning("[DamageEffect_Segment]", "BranchSegmentWithName Failed", self.SegmentName)
        end
    end
end


---PrintDsCollisionMessageOnScreen
---在屏幕左上方打印单次攻击方与受击方身上所有的碰撞通道_PrintCollision
---@param ScratchPad USPAbilityTaskScratchPad
function Ability_Task_CollisionDamage:PrintDsCollisionMessageOnScreen(ScratchPad)
    ---@type boolean
    local bShowCollisionChannel = _SP.SPAbilityUtils and _SP.SPAbilityUtils.bShowDebugCollisionChannel or false
    if bShowCollisionChannel == false then
        return
    end
    local t_cache = ScratchPad.t_cache
    local DamageSourceActor = t_cache.Owner
    local CollisionResults = t_cache.CollisionResults
    local logStr = "[Ability_Task_CollisionDamage]"
    for _, HitResult in ipairs(CollisionResults) do
        local HitActor = HitResult.Actor
        local SPActorType = GetSPActorType(HitActor)
        local HitActorChannel = ""

        local IsHitActor = HitActor == DamageSourceActor
        local primitiveComps = HitActor:K2_GetComponentsByClass(UE4.UPrimitiveComponent)
        if primitiveComps and primitiveComps:Length() > 0 then
            for i = 1, primitiveComps:Length() do
                local primitiveComp = primitiveComps:Get(i)
                local keyName = HitActor:GetName() .. "_" .. primitiveComp:GetName()
                if primitiveComp:GetCollisionEnabled() ~= UE4.ECollisionEnabled.NoCollision then
                    HitActorChannel = primitiveComp:GetCollisionObjectType()
                    if IsHitActor then
                        logStr = logStr .. "\n" .. "DamageSourceActorName: " .. keyName .. " SPActorType: " .. SPActorType .. " SourceActorChannel: " .. HitActorChannel
                    else
                        logStr = logStr .. "\n" .. "HitActorName: " .. keyName .. " SPActorType: " .. SPActorType .. " HitActorChannel: " .. HitActorChannel
                    end
                end
            end
        end
    end

    if IsValid(DamageSourceActor) then
        self:PrintDsMessageOnScreen( logStr, 88888, 5)
    end
end

---PrintDsMessageOnScreen   This function will add a debug message to the onscreen message list. It will be displayed for FrameCount frames
---在屏幕左上方打印字符串_PrintDsMessageOnScreen
---@param DebugMessage string The Message to display
---@param key number A unique key to prevent the same message from being added multiple times
---@param TimeToDisplay number How long to display the message, in seconds
function Ability_Task_CollisionDamage:PrintDsMessageOnScreen(DebugMessage, key, TimeToDisplay)
    key = key or -1
    TimeToDisplay = TimeToDisplay or 5
    UE4.UMoeBlueprintLibrary.AddOnScreenDebugMessage(key, TimeToDisplay, UE4.FColor(100, 255, 0, 255), DebugMessage, true, UE4.FVector2D(1, 1))
end

return Ability_Task_CollisionDamage