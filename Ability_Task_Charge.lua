---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by bladeyuan.
--- DateTime: 2024/6/13 2:58
---
local SPAbility = require("Feature.StarP.Script.System.Ability.SPAbilityClasses")
local SPAbilityUtils = require("Feature.StarP.Script.System.Ability.SPAbilityUtils")
local SPLuaUtility = require("Feature.StarP.Script.System.SPLuaUtility")
local AttrTypeEnum = _SPFeature.ServerEnum.StarPAttrType
---@type SPPalAIUtil
local SPPalAIUtil = require("Feature.StarP.Script.System.AI.Util.SPPalAIUtil")

---@class Ability_Task_Charge : USPChargeTask
local Ability_Task_Charge = UE4.Class(nil, "Ability_Task_Charge")

function Ability_Task_Charge:OnTaskStartBP(Context)
    local TargetArray = UE4.TArray(UE4.AActor)
    self:GetActorsForTaskBP(Context, TargetArray)

    --- 飞行星兽的冲锋需要进入飞行技能状态，解除飞行高度限制
    local selfActor = Context:GetSelfActor()
    if self.UnlimitedFlightAltitude and _SP.IsValid(selfActor) and selfActor.GetMonsterAIConfig then
        local monsterAIConfig = selfActor:GetMonsterAIConfig()
        if monsterAIConfig and monsterAIConfig.canFly == true then
            selfActor:TryEnterMotionState_New(UE4.ESPMotionState.SP_Monster_Flying_Skill, nil, UE4.EStateIdOffsetType.SP)
        end
    end

    for i = 1, TargetArray:Length() do
        local Target = TargetArray:Get(i)
        local Character = Target:Cast(UE4.ASPGameMonsterBase)
        if not Character then
            Character = Target:Cast(UE4.ASPGameCharacterBase)
        end

        if Character then
            self:Charge(Context, Character, self.ChargeType)
        end
    end
end

function Ability_Task_Charge:OnTaskTickBP(Context, DeltaTime)

    if self.BranchSegmentMaxDistance <= 0 or self.BranchSegmentName == "None" then
        return
    end

    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad or not ScratchPad.Handle then
        return
    end


    ---@type AActor
    local TargetActor = self:GetSingleActorFromTargetTypeBP(Context, UE4.EAbleAbilityTargetType.ATT_TargetActor)
    if not TargetActor then
        return
    end

    local SelfActor = Context:GetSelfActor()
    if not SelfActor then
        return
    end

     local TargetHalfHeight = 0
     local TargetCapsule = TargetActor:GetComponentByClass(UE4.UCapsuleComponent.StaticClass())
     if TargetCapsule then
         TargetHalfHeight = TargetCapsule.CapsuleHalfHeight
     end
     local TargetLocation = TargetActor:K2_GetActorLocation()
     local SelfLocation = SelfActor:K2_GetActorLocation()
     local SelfHalfHeight = 0
     local SelfCapsule = SelfActor:GetComponentByClass(UE4.UCapsuleComponent.StaticClass())
     if SelfCapsule then
         SelfHalfHeight = SelfCapsule.CapsuleHalfHeight
     end

     TargetLocation.Z = TargetLocation.Z - TargetHalfHeight
     SelfLocation.Z = SelfLocation.Z - SelfHalfHeight

    ---@comment 获取自身和目标的半径
    local SelfRadius = SPPalAIUtil.GetCharacterRadius(SelfActor)
    local TargetRadius = SPPalAIUtil.GetCharacterRadius(TargetActor)

    local Distance = math.huge
    if self.Use2DLocation then
        Distance = SPAbilityUtils.GetCharacterDistance2D(SelfLocation, TargetLocation, SelfRadius, TargetRadius)
    else
        Distance = SPAbilityUtils.GetCharacterDistance(SelfLocation, TargetLocation, SelfRadius, TargetRadius)
    end


     --_SP.Log("Ability_Task_Charge", "OnTaskTickBP", TargetLocation, SelfLocation, Distance)

    if Distance <= self.BranchSegmentMaxDistance then
        _SP.Log("Ability_Task_Charge", "BranchSegment To", self.BranchSegmentName, Distance, self.Use2DLocation, self.BranchSegmentMaxDistance)
        if not Context:GetSelfAbilityComponent():BranchSegmentWithName(Context, self.BranchSegmentName) then
            _SP.LogWarning("SPAbility", "[Ability_Task_Charge]", "BranchSegment Failed")
        end
    end

    if ScratchPad.Handle:IsCompleted() then
        -- _SP.Log("Ability_Task_Charge", "ChargeProcess is Completed, OnTaskTickBP BranchSegment To", self.BranchSegmentName)
        if not Context:GetSelfAbilityComponent():BranchSegmentWithName(Context, self.BranchSegmentName) then
            _SP.LogWarning("SPAbility", "[Ability_Task_Charge]", "BranchSegment Failed")
        end
    end
end

function Ability_Task_Charge:OnTaskEndBP(Context, Result)
    --- 结束冲锋时退出飞行技能状态
    local selfActor = Context:GetSelfActor()
    if self.UnlimitedFlightAltitude and _SP.IsValid(selfActor) and selfActor.GetMotionState and selfActor.TryEnterMotionState_New then
        local motionState = selfActor:GetMotionState_New()
        if motionState == UE4.USPGameLibrary.GetStateIDWithOffset(UE4.ESPMotionState.SP_Monster_Flying_Skill, UE4.EStateIdOffsetType.SP) then
            local MonsterBaseData = selfActor:GetMonsterBaseData()
            if MonsterBaseData and (not MonsterBaseData.IsDead) then
                -- 判断是否正在战斗中
                if MonsterBaseData.IsInCombat then
                    selfActor:TryEnterMotionState_New(UE4.ESPMotionState.SP_Monster_Flying_Battle, nil, UE4.EStateIdOffsetType.SP, true)
                end
            end
        end
    end
    if Result == UE4.EAbleAbilityTaskResult.Successful then
        _SP.Log("SPAbility", "[Ability_Task_Charge]", "Result == UE4.EAbleAbilityTaskResult.Successful")
        --return
    end

    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad or not ScratchPad.Handle then
        return
    end

    ScratchPad.Handle:Abort()
    ScratchPad.Handle = nil
    _SP.Log("SPAbility", "[Ability_Task_Charge]", "TaskEnd")
end

function Ability_Task_Charge:Charge(Context, Target, ChargeType)
    local ECollisionShape = _SP.SPAbilityUtils.ESPChargeType
    local Handle

    local OffsetPitch = self.RotateOffset.X
    local OffsetYaw = self.RotateOffset.Y
    local OffsetRoll = self.RotateOffset.Z

    local IgnorePitch = self.IgnoreRotationPitch
    local IgnoreYaw = self.IgnoreRotationYaw
    local IgnoreRoll = self.IgnoreRotationRoll

    local MaxHSpeed = self.MaxHSpeed
    local MaxVSpeed = self.MaxVSpeed

    if self.bSupportScale then
        MaxHSpeed = MaxHSpeed * self:GetOwnerScale_Lua(Context) * self.ScaleCoefficient
        MaxVSpeed = MaxVSpeed * self:GetOwnerScale_Lua(Context) * self.ScaleCoefficient
    end

    _SP.LogWarning("SPAbility", "Ability_Task_Charge Start", tostring(Context:GetAbilityId()), tostring(ChargeType))

    if ChargeType == ECollisionShape.FollowTarget then
        local targetActor = self:GetSingleActorFromTargetTypeBP(Context, UE4.EAbleAbilityTargetType.ATT_TargetActor)
        if not targetActor or not _SP.IsValid(targetActor) then
            _SP.LogWarning("SPAbility", "Ability_Task_Charge", "Charge targetActor is nil")
            return
        end
        local params = UE4.USPCharacterMovementLibrary.GetSpeedCurveParameter(self.HSpeedCurve, MaxHSpeed, self.VSpeedCurve, MaxVSpeed, self.Time)
        local config = UE4.USPCharacterMovementLibrary.GetMovementConfigV2(self.UseVertical, OffsetPitch, OffsetYaw, OffsetRoll, IgnorePitch, IgnoreYaw, IgnoreRoll, self.ToleranceDistance, self.Timeout, self.VelocityMode)

        Handle = Target:MoveFollowTargetByCurve(targetActor, params, config)
    elseif ChargeType == ECollisionShape.Target then
        local targetActor = self:GetSingleActorFromTargetTypeBP(Context, UE4.EAbleAbilityTargetType.ATT_TargetActor)
        if not targetActor or not _SP.IsValid(targetActor) then
            _SP.LogWarning("SPAbility", "Ability_Task_Charge", "Charge targetActor is nil")
            return
        end
        local params = UE4.USPCharacterMovementLibrary.GetSpeedCurveParameter(self.HSpeedCurve, MaxHSpeed, self.VSpeedCurve, MaxVSpeed, self.Time)
        local config = UE4.USPCharacterMovementLibrary.GetMovementConfigV2(self.UseVertical, OffsetPitch, OffsetYaw, OffsetRoll, IgnorePitch, IgnoreYaw, IgnoreRoll, self.ToleranceDistance, self.Timeout, self.VelocityMode)

        Handle = Target:MoveToTargetLocationByCurve(targetActor:K2_GetActorLocation(), params, config)
    elseif ChargeType == ECollisionShape.Forward then
        local params = UE4.USPCharacterMovementLibrary.GetSpeedCurveParameter(self.HSpeedCurve, MaxHSpeed, self.VSpeedCurve, MaxVSpeed, self.Time)
        local config = UE4.USPCharacterMovementLibrary.GetMovementConfigV1(self.UseVertical, OffsetPitch, OffsetYaw, OffsetRoll, IgnorePitch, IgnoreYaw, IgnoreRoll)

        Handle = Target:MoveForwardByCurve(params, config)
    elseif ChargeType == ECollisionShape.Aim then
        --向瞄准方向位移固定距离
        local cameramgr = UE4.UGameplayStatics.GetPlayerCameraManager(_SP.GetCurrentWorld(), 0)
        local aimvector = cameramgr:GetCameraRotation():GetForwardVector()
        aimvector.Z = 0
        local params = UE4.USPCharacterMovementLibrary.GetSpeedCurveParameter(self.HSpeedCurve, self.MaxHSpeed, self.VSpeedCurve, self.MaxVSpeed, self.Time)
        local config = UE4.USPCharacterMovementLibrary.GetMovementConfigV1(self.UseVertical, OffsetPitch, OffsetYaw, OffsetRoll, IgnorePitch, IgnoreYaw, IgnoreRoll)
        Handle = Target:MoveWorldDirByCurve(aimvector, params, config)
    elseif ChargeType == ECollisionShape.AlwayForward then
        local params = UE4.USPCharacterMovementLibrary.GetSpeedCurveParameter(self.HSpeedCurve, MaxHSpeed, self.VSpeedCurve, MaxVSpeed, self.Time)
        local config = UE4.USPCharacterMovementLibrary.GetMovementConfigV1(self.UseVertical, OffsetPitch, OffsetYaw, OffsetRoll, IgnorePitch, IgnoreYaw, IgnoreRoll)
        config.bUpdateDir = true
        Handle = Target:MoveForwardByCurve(params, config)
    elseif ChargeType == ECollisionShape.ForwardAndReBound then
        local params = UE4.USPCharacterMovementLibrary.GetSpeedCurveParameter(self.HSpeedCurve, MaxHSpeed, self.VSpeedCurve, MaxVSpeed, self.Time, self.BoundPartical, self.BankName, self.EventName)
        local config = UE4.USPCharacterMovementLibrary.GetMovementConfigV1(self.UseVertical, OffsetPitch, OffsetYaw, OffsetRoll, IgnorePitch, IgnoreYaw, IgnoreRoll)

        Handle = Target:MoveForwardAndReboundByCurve(params, config)
    end

    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad then
        return
    end

    ScratchPad.Handle = Handle
end

function Ability_Task_Charge:IsSingleFrameBP()
    return false
end

function Ability_Task_Charge:ResetScratchPadBP(ScratchPad)
    if ScratchPad then
        ScratchPad.Handle = nil
    end
end

function Ability_Task_Charge:GetTaskScratchPadClassBP(Context)
    return SPAbilityUtils.LoadScratchPadClass(SPAbility.ScratchPadClass.Charge)
end

function Ability_Task_Charge:GetOwnerScale_Lua(Context)
    local owner = Context:GetOwner()
    local nScale = 1.0

    if owner:GetSPActorType() == UE4.ESPActorType.Pet then
        local bossType = owner:GetAttributeValue(AttrTypeEnum.SPAT_BossType)
        if bossType == _SPFeature.ServerEnum.SPPetBossType.SP_BOSS_GENERAL then
            nScale = owner.MonsterConfig.monsterScale or 1.0
        end
        if nScale <= 0 then
            nScale = 1.0
        end
    end

    -- _SP.Log("SPAbility", "Ability_Task_Charge", "GetOwnerScale_Lua", nScale)

    return nScale
end

return Ability_Task_Charge